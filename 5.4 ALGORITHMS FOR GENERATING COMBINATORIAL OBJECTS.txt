5.4 ALGORITHMS FOR GENERATING COMBINATORIAL OBJECTS

In this section, we keep our promise to discuss algorithms for generating combinatorial objects. The most important types of combinatorial objects are permutations, combinations, and subsets of a given set. They typically arise in problems that require a consideration of different choices. We already encountered them in Chapter 3 when we discussed exhaustive search. Combinatorial objects are studied in a branch of discrete mathematics called combinatorics. Mathematicians, of course, are primarily interested in different counting formulas; we should be grateful for such formulas because they tell us how many items need to be generated. (In particular, they warn us that the number of combinatorial objects typically grows exponentially or even faster as a function of the problem's size.) But our
primary interest here lies in algorithms for generating combinatorial objects, not just in counting them. 

GENERATING PERMUTATIONS
We start with permutations. To simplify, we assume that the underlying set whose elements need to be permuted is simply the set of integers from 1 to n; more generally, they can be interpreted as indices of elements in an n-element set {a1,...an}. What would the decrease by one technique suggest for the problem of generating all n! permutations of {1, ... , n)? The smaller-by-one problem is to generate all (n - 1)! permutations. Assuming that the smaller problem is solved, we can get a solution to the larger one by inserting n in each of the n possible positions among elements of every permutation of n - 1 elements. All the permutations obtained in this fashion will be distinct (why?), and their total number will be n(n- 1)! = n!. Hence, we will obtain all the permutations of {1, ... , n). 

We can insert n in the previously generated permutations either left to right or right to left. It turns out that it is beneficial to start with inserting n into 12 ... (n - 1) by moving right to left and then switch direction every time a new permutation of {1, ... , n - 1] needs to be processed.

The advantage of this order stems from the fact that it satisfies the minimalchange requirement: each permutation can be obtained from its immediate predecessor by excha1;1ging just two elements in it. (Check this for the permutations generated in Figure 5.12.) The minimal-change requirement is beneficial both for the algorithm's speed and for applications using the permutations. For example, in Section 3.4, we needed permutations of cities to solve the traveling salesman problem by exhaustive search. If such permutations are generated by a minimalchange algorithm, we can compute the length of a new tour from the length of its predecessor in constant rather than linear time (how?). 



ALGORITHM .TohnsonTrotter(n)
//Implements Johnson-Trotter algorithm for generating permutations
//Input: A positive integer n
//Output: A list of all permutations of {1, ... , n) ~~ ~
initialize the first permutation with 1 2 ... n
while the last permutation has a mobile element do
find its largest mobile element k ,
swap k and the adjacent integer k.'s arrow points to
reverse the direction of all the elements that are larger thank
add the new permutation to the list 


GENERATING SUBSETS
Recall that in Section 3.4 we examined the knapsack problem that asks to find the most valuable subset of items that fits a knapsack of a given capacity. The exhaustive-search approach to solving this problem discussed there was based on generating all subsets of a given set of items. In this section, we discuss algorithms for generating all 2^n subsets of an abstract set A= {a1, ... , a,). (Mathematicians call the set of all subsets of a set its power set.) 





















































































